<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>65. Checkpointing Storage: Saving Training Progress</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
* { margin: 0; padding: 0; box-sizing: border-box; }
:root {
    --primary-color: #00796B;
    --secondary-color: #009688;
    --accent-color: #4DB6AC;
    --bg-color: #E0F2F1;
    --card-bg: #FFFFFF;
    --text-color: #1A1A1A;
    --border-color: #80CBC4;
    --shadow: 0 2px 8px rgba(0, 121, 107, 0.1);
}
body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
    background: var(--bg-color);
    color: var(--text-color);
    line-height: 1.6;
}
header {
    text-align: center;
    padding: 50px 40px;
    background: linear-gradient(135deg, #00796B, #009688);
    color: white;
}
header h1 {
    font-size: 2.5rem;
    font-weight: 700;
    margin-bottom: 12px;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
}
.subtitle {
    font-size: 1.2rem;
    opacity: 0.95;
    font-weight: 300;
}
.author-credit {
    font-size: 1rem;
    font-weight: 600;
    margin-top: 15px;
    padding: 8px 20px;
    background: rgba(255, 255, 255, 0.25);
    border-radius: 6px;
    display: inline-block;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
    border: 2px solid rgba(255, 255, 255, 0.4);
}

.sidebar-wrapper {
    display: flex;
    min-height: calc(100vh - 200px);
}
.nav-menu {
    width: 280px;
    min-width: 280px;
    background: #80DEEA;
    border-right: 2px solid var(--border-color);
    padding: 20px 0;
    position: sticky;
    top: 0;
    height: calc(100vh - 200px);
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 4px;
}
.nav-link {
    color: var(--text-color);
    text-decoration: none;
    padding: 12px 20px;
    margin: 0 10px;
    border-radius: 6px;
    transition: all 0.2s ease;
    font-weight: 500;
    display: block;
}
.nav-link:hover, .nav-link.active {
    background: var(--primary-color);
    color: white;
}
.main-content-wrapper {
    flex: 1;
    width: calc(100% - 280px);
    min-width: 0;
}

.section {
    padding: 40px;
    min-height: calc(100vh - 200px);
    border-bottom: 1px solid var(--border-color);
    max-width: 100%;
}
.section h2 {
    font-size: 2.2rem;
    margin-bottom: 20px;
    color: var(--primary-color);
    border-bottom: 3px solid var(--primary-color);
    padding-bottom: 10px;
}
.concept-card {
    background: var(--card-bg);
    padding: 25px;
    border-radius: 12px;
    border: 2px solid var(--border-color);
    margin: 20px 0;
    box-shadow: var(--shadow);
}
.concept-card h3 {
    color: var(--primary-color);
    margin-bottom: 15px;
    font-size: 1.4rem;
}
.mermaid { margin: 30px 0; text-align: center; }
.example-box {
    background: linear-gradient(135deg, #E0F2F1, #B2DFDB);
    border-left: 5px solid var(--primary-color);
    padding: 20px 25px;
    margin: 20px 0;
    border-radius: 8px;
}
.example-box strong {
    color: var(--primary-color);
    display: block;
    margin-bottom: 10px;
    font-size: 1.1rem;
}
footer {
    text-align: center;
    padding: 40px;
    background: #80CBC4;
    border-top: 2px solid var(--border-color);
    color: var(--text-color);
}
@media (max-width: 768px) {
    header h1 { font-size: 2rem; }
    
    .nav-menu {
        width: 100%;
        min-width: 100%;
        height: auto;
        position: relative;
        flex-direction: row;
        flex-wrap: wrap;
        padding: 10px;
        border-right: none;
        border-bottom: 2px solid var(--border-color);
    }
    .nav-link {
        padding: 8px 15px;
        margin: 4px;
    }
    
    .section { padding: 25px 20px; }
}
    .section {
    padding: 40px;
    min-height: calc(100vh - 200px);
    border-bottom: 1px solid var(--border-color);
    max-width: 100%;
}
    </style>
</head>
<body>
    <header>
        <h1>65. Checkpointing Storage</h1>
        <p class="subtitle">Saving Training Progress Efficiently</p>
        <p class="author-credit">Explained by Naman Adep</p>
    </header>

    <div class="sidebar-wrapper">
    <nav class="nav-menu">
        <a href="#overview" class="nav-link active">Overview</a>
        <a href="#checkpoint-types" class="nav-link">Checkpoint Types</a>
        <a href="#storage-strategies" class="nav-link">Storage Strategies</a>
        <a href="#optimization" class="nav-link">Optimization</a>
        <a href="#best-practices" class="nav-link">Best Practices</a>
    </nav>
    <div class="main-content-wrapper">
        <main>
        <section id="overview" class="section">
            <h2>Checkpointing Storage Overview</h2>
            <p>
                Checkpointing is the process of saving training state (model weights, optimizer state, training progress) 
                to storage, enabling training to resume after interruptions. Checkpoint storage requires careful consideration 
                of storage type, location, and frequency to balance performance, reliability, and cost. Efficient checkpointing 
                strategies minimize checkpoint time while ensuring training progress is safely preserved. Checkpoint storage 
                typically requires high-performance storage for fast checkpoint writes and reads, with sufficient capacity 
                to store multiple checkpoints.
            </p>

            <div class="mermaid">
                graph TD
                    A[Training Job] --> B[Checkpoint Interval]
                    B --> C[Save Checkpoint]
                    C --> D[Model Weights]
                    C --> E[Optimizer State]
                    C --> F[Training State]
                    
                    D --> G[Storage]
                    E --> G
                    F --> G
                    
                    style A fill:#00796B
                    style C fill:#009688
                    style G fill:#4DB6AC
            </div>

            <div class="example-box">
                <strong>Checkpointing:</strong>
                Checkpointing saves training state, allowing you to resume from the last checkpoint if training is 
                interrupted. Checkpoint storage must be fast to minimize save overhead and reliable to ensure progress 
                is preserved. Fast checkpoint storage reduces training downtime, while reliable storage ensures no 
                progress is lost.
            </div>

            <div class="mermaid">
                mindmap
                  root((Checkpointing Storage))
                    Requirements
                      Fast Storage
                      Reliable Storage
                      Minimize Overhead
                    Storage Tiers
                      Local Storage
                      Network Storage
                      Object Storage
                    Strategy
                      Tiered Approach
                      Asynchronous Checkpointing
                      Compression
                      Retention Policies
            </div>
        </section>

        <section id="checkpoint-types" class="section">
            <h2>Checkpoint Types</h2>
            <p>
                Different checkpoint types store different amounts of information, balancing checkpoint size, save time, 
                and recovery capabilities.
            </p>

            <div class="concept-card">
                <h3>Full Checkpoints</h3>
                <ul style="margin-top: 15px; padding-left: 20px; line-height: 2;">
                    <li><strong>Complete State:</strong> Model weights, optimizer state, training state</li>
                    <li><strong>Largest Size:</strong> Largest checkpoint size</li>
                    <li><strong>Complete Recovery:</strong> Complete training recovery</li>
                    <li><strong>Use Case:</strong> Critical checkpoints, final checkpoints</li>
                </ul>
            </div>

            <div class="mermaid">
                flowchart TD
                    A[Model-Only Checkpoints] --> B[Model Weights<br/>Only Weights]
                    A --> C[Smaller Size<br/>Smaller than Full]
                    A --> D[Faster Save<br/>Faster Save Time]
                    A --> E[Use Case<br/>Frequent, Inference]
                    
                    style A fill:#00796B
                    style B fill:#009688
                    style C fill:#4DB6AC
                    style D fill:#80CBC4
                    style E fill:#B2DFDB
                </div>

            <div class="concept-card">
                <h3>Incremental Checkpoints</h3>
                <ul style="margin-top: 15px; padding-left: 20px; line-height: 2;">
                    <li><strong>Delta Updates:</strong> Only changes since last checkpoint</li>
                    <li><strong>Smallest Size:</strong> Smallest checkpoint size</li>
                    <li><strong>Fastest Save:</strong> Fastest checkpoint save</li>
                    <li><strong>Use Case:</strong> Very frequent checkpoints</li>
                </ul>
            </div>
        </section>

        <section id="storage-strategies" class="section">
            <h2>Storage Strategies</h2>
            <p>
                Checkpoint storage strategies balance performance, reliability, and cost. Different storage types serve 
                different checkpoint needs.
            </p>

            <div class="mermaid">
                graph LR
                    A[Checkpoint Storage] --> B[Local Storage<br/>Fast, Limited]
                    A --> C[Network Storage<br/>Shared, Scalable]
                    A --> D[Object Storage<br/>Massive, Cost-Effective]
                    
                    style A fill:#00796B
                    style B fill:#009688
                    style C fill:#4DB6AC
                    style D fill:#80CBC4
            </div>

            <div class="mermaid">
                flowchart TD
                    A[Local Storage] --> B[Fast Access<br/>Fastest Save/Load]
                    A --> C[Limited Capacity<br/>Limited Storage]
                    A --> D[Node-Specific<br/>Not Shared]
                    A --> E[Use Case<br/>Frequent, Temporary]
                    
                    style A fill:#00796B
                    style B fill:#009688
                    style C fill:#4DB6AC
                    style D fill:#80CBC4
                    style E fill:#B2DFDB
                </div>

            <div class="concept-card">
                <h3>Network Storage</h3>
                <ul style="margin-top: 15px; padding-left: 20px; line-height: 2;">
                    <li><strong>Shared Access:</strong> Shared across nodes</li>
                    <li><strong>Scalable:</strong> Scalable capacity</li>
                    <li><strong>Good Performance:</strong> Good checkpoint performance</li>
                    <li><strong>Use Case:</strong> Production checkpoints, multi-node training</li>
                </ul>
            </div>

            <div class="mermaid">
                flowchart LR
                    A[Object Storage] --> B[Massive Scale<br/>Massive Capacity]
                    A --> C[Cost-Effective<br/>Long-Term Storage]
                    A --> D[Slower Access<br/>Slower than Local/Network]
                    A --> E[Use Case<br/>Long-Term Archive]
                    
                    style A fill:#00796B
                    style B fill:#009688
                    style C fill:#4DB6AC
                    style D fill:#FF6B6B
                    style E fill:#80CBC4
                </div>
        </section>

        <section id="optimization" class="section">
            <h2>Checkpoint Optimization</h2>
            <p>
                Optimizing checkpoint operations reduces training overhead and improves efficiency. Optimization strategies 
                include asynchronous checkpointing, compression, and smart checkpoint frequency.
            </p>

            <div class="mermaid">
                flowchart TD
                    A[Asynchronous Checkpointing] --> B[Non-Blocking<br/>Background Checkpoint]
                    A --> C[Training Continues<br/>During Checkpoint]
                    A --> D[Reduced Overhead<br/>Minimal Overhead]
                    A --> E[Use Case<br/>Frequent Checkpointing]
                    
                    style A fill:#00796B
                    style B fill:#009688
                    style C fill:#4DB6AC
                    style D fill:#80CBC4
                    style E fill:#B2DFDB
                </div>

            <div class="mermaid">
                flowchart TD
                    A[Checkpoint Compression] --> B[Size Reduction<br/>Reduce Size]
                    A --> C[Faster Transfer<br/>Faster Network]
                    <li><strong>CPU Overhead:</strong> Some CPU overhead</li>
                    <li><strong>Use Case:</strong> Large checkpoints, network storage</li>
                </ul>
            </div>

            <div class="concept-card">
                <h3>Checkpoint Frequency</h3>
                <ul style="margin-top: 15px; padding-left: 20px; line-height: 2;">
                    <li><strong>Balance:</strong> Balance checkpoint frequency vs overhead</li>
                    <li><strong>Risk Assessment:</strong> Assess failure risk</li>
                    <li><strong>Training Duration:</strong> Consider training duration</li>
                    <li><strong>Best Practice:</strong> Checkpoint every N epochs or time interval</li>
                </ul>
            </div>
        </section>

        <section id="best-practices" class="section">
            <h2>Best Practices</h2>
            <p>
                Following checkpoint storage best practices ensures reliable training progress preservation while minimizing 
                performance impact.
            </p>

            <div class="concept-card">
                <h3>Storage Configuration</h3>
                <ul style="margin-top: 15px; padding-left: 20px; line-height: 2;">
                    <li><strong>High Performance:</strong> Use high-performance storage for checkpoints</li>
                    <li><strong>Sufficient Capacity:</strong> Ensure sufficient storage capacity</li>
                    <li><strong>Redundancy:</strong> Use redundant storage for reliability</li>
                    <li><strong>Monitoring:</strong> Monitor checkpoint storage usage</li>
                </ul>
            </div>

            <div class="concept-card">
                <h3>Checkpoint Management</h3>
                <ul style="margin-top: 15px; padding-left: 20px; line-height: 2;">
                    <li><strong>Retention Policy:</strong> Implement checkpoint retention policy</li>
                    <li><strong>Cleanup:</strong> Clean up old checkpoints</li>
                    <li><strong>Versioning:</strong> Version checkpoints appropriately</li>
                    <li><strong>Documentation:</strong> Document checkpoint locations</li>
                </ul>
            </div>

            <div class="concept-card">
                <h3>Recovery Planning</h3>
                <ul style="margin-top: 15px; padding-left: 20px; line-height: 2;">
                    <li><strong>Test Recovery:</strong> Test checkpoint recovery</li>
                    <li><strong>Backup Strategy:</strong> Implement backup strategy</li>
                    <li><strong>Disaster Recovery:</strong> Plan for disaster recovery</li>
                    <li><strong>Documentation:</strong> Document recovery procedures</li>
                </ul>
            </div>

            <div class="example-box">
                <strong>Checkpoint Strategy:</strong>
                Implement a tiered checkpoint strategy: use local storage for frequent checkpoints, network storage for 
                production checkpoints, and object storage for long-term archive. Use asynchronous checkpointing to 
                minimize training overhead, compress checkpoints for network storage, and implement retention policies 
                to manage storage costs. Test recovery procedures regularly to ensure checkpoints work correctly.
            </div>
        </section>
            </main>

            </div>
</div>

    <footer>
        <p>Checkpointing Storage Guide | Saving Training Progress</p>
    </footer>

    <script>
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
        
        document.querySelectorAll('.nav-link').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href');
                const targetSection = document.querySelector(targetId);
                if (targetSection) {
                    targetSection.scrollIntoView({ behavior: 'smooth' }
);
                    document.querySelectorAll('.nav-link').forEach(l => l.classList.remove('active'));
                    this.classList.add('active');
                }

            });
        });

        const sections = document.querySelectorAll('.section');
        const navLinks = document.querySelectorAll('.nav-link');
        
        window.addEventListener('scroll', () => {
            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                if (pageYOffset >= sectionTop - 200) {
                    current = section.getAttribute('id');
                }

            });
            
            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === `#${current}`) {
                    link.classList.add('active');
                }
            });
        });
    </script>
</body>
</html>
